---
layout: post
title: 오토에버 클라우드 2기 1일차
tags: PYTHON
excerpt_image: "https://github.com/user-attachments/assets/fa4bfe08-4293-41e6-84d5-e986e7640d17"
---

파이썬 프로그래밍 1일차

현대 오토에버 SW 스쿨 2기 클라우드에 대한 전반적인 OT 실행

마지막 프로젝트 
* 쿠버네티스 클러스터 환경 기반 웹 애플리케이션 관리 자동화 프로젝트
* 클라우드 플랫폼에서의 로그 분석 시스템 개발 프로젝트
* 클라우드 환경 기반 데이터 파이프라인 자동화 프로젝트
* 하이브리드 클라우드를 이용한 메시지 발송 이중화 프로젝트

 마지막 프로젝트 선정을 해야하는데 클랑우드 환경 기반 데이터 파이프라인 자동화 프로젝트가 가장 흥미롭게 느껴져서 그에 해당하는 프로젝트를 지금부터 생각해 봐야겠다

이후 PYTHON을 설치하면서 **PATH: 명령어를 찾는 위치** 설정을 아무생각 없이 체크 했었지만 PATH가 명령어를 찾는 위치라는걸 이해했다

&nbsp;

### 파이썬 프로젝트 종류
1. 가상화 이용
    별도의 파이썬 실행환경을 생성해서 이용한다
    개발환경과 실행환경 모두 같은 조건을 갖추기 위해서 가상환경에서 실행을 해 다른 컴퓨터에서도 같은 버전의 파이썬과 패키지를 이용할 수 있다
    여기서 운영체제까지 가상화를 이용할 수도 있다(DOCKER)

2. 가상화 이용 X
   따로 설정을 하지 않고 현재 컴퓨터 자체에 설치, 프로젝트를 다른 컴퓨터로 이동하면 제대로 안될 수 있다 환경설정을 별도의 파일에 저장해야한다

&nbsp;

### 가상환경 이용하기
`python -m venv first` first 이름의 폴더를 생성하고 가상환경을 만들어준다
가상환경을 이용하기 위해서는 활성화 시켜줘야 하는데 권한 오류가 발생

<center>
<img src="https://github.com/user-attachments/assets/fa4bfe08-4293-41e6-84d5-e986e7640d17" style="zoom:50%;">
</center>



1.Windows PowerShell 관리자로 실행
2.Set-ExecutionPolicy RemoteSigned 입력 후 Y 입력
3.다시 활성화 시도
이렇게 하고 `.\first\Scripts\activate`을 해서 정상적으로 실행함

&nbsp;

### 파이썬 구성 요소
* literal: 개발자가 직접 입력한 데이터 프로그램이 끝날 때까지 메모리에 남아있음
* variable: 데이터를 재사용하기 위해서 저장한 공간에 이름을 붙임
* function: 자주 사용하는 코드를 이름으로 묶어줌(한번에 실행되는 코드의 모임)
* class: 같은 목적의 코드가 묶임 클래스(모델하우스)와 인스턴스,객체(집)
* module: 위 요소들을 묶어 놓은것
* package: 관련된 모듈을 묶어 놓은것

&nbsp;

`"""`이걸 이용해서 여러줄의 주석을 파이썬에서 처리한적이 있는데 이거 자체를 여러줄의 문자열을 그대로 변수에 넣어서 사용한적도 있었다 그때는 자세하게 생각해본적이 없었는데 `"""`는 단순히 문자열을 literal로 처리해 주석으로 이용한것을 깨달았다

&nbsp;

### dir(자료형, 데이터)

`print(dir("안녕"))` -> 안녕 문자열을 가지고 수행할 수 있는 작업을 확인

``` cmd
['__abs__', '__add__', '__and__', '__bool__', '__ceil__', '__class__', '__delattr__', '__dir__', '__divmod__', '__doc__', '__eq__', '__float__', '__floor__', '__floordiv__', '__format__', '__ge__', '__getattribute__', '__getnewargs__', '__getstate__', '__gt__', '__hash__', '__index__', '__init__', '__init_subclass__', '__int__', '__invert__', '__le__', '__lshift__', '__lt__', '__mod__', '__mul__', '__ne__', '__neg__', '__new__', '__or__', '__pos__', '__pow__', '__radd__', '__rand__', '__rdivmod__', '__reduce__', '__reduce_ex__', '__repr__', '__rfloordiv__', '__rlshift__', '__rmod__', '__rmul__', '__ror__', '__round__', '__rpow__', '__rrshift__', '__rshift__', '__rsub__', '__rtruediv__', '__rxor__', '__setattr__', '__sizeof__', '__str__', '__sub__', '__subclasshook__', '__truediv__', '__trunc__', '__xor__', 'as_integer_ratio', 'bit_count', 'bit_length', 'conjugate', 'denominator', 'from_bytes', 'imag', 'is_integer', 'numerator', 'real', 'to_bytes']
```

`print("hello"+" world!")`

`help('hello'.__add__)` 사용 방법 출력

``` CMD
Help on method-wrapper:

__add__(value, /) unbound builtins.str method
    Return self+value.
```

&nbsp;

```pytho
print("hello".__add__(" world!"))

#2가지 모두 hello world!출력

help(int.__add__)

print(int.__add__(23,33))
```

``` cmd
Help on wrapper_descriptor:

__add__(self, value, /) unbound builtins.int method
    Return self+value.

56
```

&nbsp;

``` python
print(str.upper("hello"))

#str은 예약어가 아님 python에서 제공한다고 해서 다 예약어는 아니다 str은 사용자 정의 이름이다

str = 10

print(str.upper("hello"))
```

``` cmd
HELLO
Traceback (most recent call last):
  File "c:\Users\minjeong kim\Desktop\python\first\sample.py", line 17, in <module>
    print(str.upper("hello"))
          ^^^^^^^^^
AttributeError: 'int' object has no attribute 'upper'

```

&nbsp;

``` python
import keyword

print(keyword.kwlist)#예약어 확인
```

``` cmd
['False', 'None', 'True', 'and', 'as', 'assert', 'async', 'await', 'break', 'class', 'continue', 'def', 'del', 'elif', 'else', 'except', 'finally', 'for', 'from', 'global', 'if', 'import', 'in', 'is', 'lambda', 'nonlocal', 'not', 'or', 'pass', 'raise', 'return', 'try', 'while', 'with', 'yield'] str은 존재하지 않음
```

예약어에는 값 할당이 불가능 하다

&nbsp;

### 현재 파이썬에서 모듈을 찾기

가상환경이나 python을 여러개 사용하는 경우 모듈을 import하는 경우 경로가 다른 경우가 존재한다 이때 아래 명령어로 현재 파이썬에서 모듈을 찾는 순서를 알 수 있다

``` python
import sys

print(sys.path)
```

``` cmd
['c:\\Users\\minjeong kim\\Desktop\\python\\first',
'C:\\Users\\minjeong kim\\AppData\\Local\\Programs\\Python\\Python313\\python313.zip', 'C:\\Users\\minjeong kim\\AppData\\Local\\Programs\\Python\\Python313\\DLLs', 'C:\\Users\\minjeong kim\\AppData\\Local\\Programs\\Python\\Python313\\Lib', 'C:\\Users\\minjeong kim\\AppData\\Local\\Programs\\Python\\Python313', 'C:\\Users\\minjeong kim\\AppData\\Local\\Programs\\Python\\Python313\\Lib\\site-packages']
```

&nbsp;

### 파이썬 int는 무제한이다

파이썬만에서 int 무제한으로 쓸 수 있다고 한다

``` python
import sys
a = 1024 

print(sys.getsizeof(a)) 	# 메모리 사이즈를 확인
#28을 출력
print(type(a))
#int를 출력
```

C와 다르게 (C는 4bytes 사용) 7배나 많은 크기를 차지한다 C언어(32비트 시스템)는 -2^31부터 2^31만큼의 크기를 저장할 수 있는데 이를 넘어가면 오버플로우가 발생한다 1은 부호

파이썬의 int는 **임의 정밀도**를 이용하기 때문에 정수를 숫자 배열로 간주하고 자리수 단위로 쪼개서 배열로 표현해 무제한적으로 담을 수 있다

**값이 커질 때마다 4비트씩 추가로 상승**

``` python
import sys
a = 1024 

print(sys.getsizeof(a)) 	# 메모리 사이즈를 확인
#28을 출력
print(type(a))
#int를 출력

a= 2**30
print(sys.getsizeof(a)) 	# 메모리 사이즈를 확인

print(type(a))

a= 2**34
print(sys.getsizeof(a)) 	# 메모리 사이즈를 확인

print(type(a))

a= 2**60
print(sys.getsizeof(a)) 	# 메모리 사이즈를 확인

print(type(a))
```

```cmd
28
<class 'int'>
32
<class 'int'>
32
<class 'int'>
36
<class 'int'>
```

&nbsp;

### 파이썬 문자열 크기 비교

파이썬에서 문자열을 비교한다면 같다 다르다를 비교한다 여기서 대소 비교도 가능한데

``` python
print("ACa" < "aCA")# true

print("ACaaaa" < "aCA")# true
```

경우의 수 모두 아스키 코드 값을 더한다 1번에서 false가 아니므로 이건 아님

2번을 확인해본 결과 맨 앞의 아스키 코드만 비교해서 결정하는것 같다



### 2진수

1의 보수: 0과 1을 바꾼다

2의 보수: 1의 보수에 +1을 한다

-1을 1의 2의 보수로 볼 수 있는데 모든 비트가 1이라서 가장 큰 숫자가 될 수 있다

파일 복사는 or 연산

&nbsp;

### **불변(immutable)** 자료형 저장 방식

``` python
a= 2**60
b = 2**60
c= [2,3]

print(id(a))#2339055514272
print(id(b))#2339055514272
print(id(c[0]))#140723985327048
print(id(c[1]))#140723985327080

d = 'adsfsa'
print(id(d))#1851457295232
print(id(d[0]))#140723985391584
print(d[0])
print(id(d[1]))#140723985391728
print(d[1])
```

데이터를 저장할때 특정 값은 한번만 저장되며 같은 값을 이용할려면 같은 위치에서 가져온다 같은 ID를 사용하는것을 코드로 확인

하지만 이 ID가 메모리 위치를 나타내는것을 아니다 리스트에서는 연속적으로 32가 증가해서 주소값처럼 보였지만 문자열 하나씩 저장하는것의 ID를 보면 주소값이 크게 다르다 이는 해시를 사용해서 그럴수 있다 또한 d의 ID와 d의 한가지 요소의 id값이 다른건 d는 문자열 자체를 저장하는것이고 d[0]은 내부요소 문자열 하나를 저장하는 id를 나타내기 때문에 다르다 

&nbsp;

## 새로 알게된 것

* 파이썬의 PATH설정
* 윈도우에서 파이썬 권한 오류 해결
* dir을 이용해서 사용 가능한 명령어 확인
* 파이썬에서 int는 무제한이다
* 문자열의 크기 비교
* 파이썬 불변 데이터 저장 방식