---
layout: post
title: 오토에버 클라우드 2기 61일차
tags: aws ecs
image: 'https://image.minnnningnas.duckdns.org/images/a7955af3-38ec-4fbe-922f-50e7f902ee52.webp'
---

## 1. ECS 개요

### 1-1. ECS란 무엇인가?

Amazon ECS(Elastic Container Service)는 AWS 환경에 최적화된 **완전 관리형 컨테이너 오케스트레이션 서비스** Docker 컨테이너를 AWS 클라우드에서 손쉽게 실행, 중지 및 관리할 수 있게 해주며, Docker Swarm이나 Kubernetes와 유사한 역할을 수행한다

&nbsp;

### 1-2. 왜 ECS를 사용?

- **단순함**: 쿠버네티스(EKS)에 비해 학습 곡선이 낮고, AWS 콘솔을 통해 직관적으로 클러스터와 서비스를 구성할 수 있음
- **AWS 생태계와의 완벽한 통합**: IAM(보안), VPC(네트워크), Application Load Balancer(로드밸런싱), CloudWatch(모니터링) 등 다른 AWS 서비스와 긴밀하게 통합되어 있어, AWS 환경에서 컨테이너를 운영하기 위한 모든 기능을 유기적으로 활용할 수 있음
- **서버리스 옵션 (Fargate)**: EC2 인스턴스(서버)를 직접 프로비저닝하거나 관리할 필요 없이 컨테이너를 실행할 수 있는 **서버리스** 옵션을 제공하여, 인프라 관리 부담을 최소화할 수 있음

&nbsp;

## 2. ECS 핵심 구성 요소

ECS는 여러 구성 요소들이 유기적으로 결합하여 동작하기 때문에 각 요소의 역할을 이해하는 것이 중요

- **클러스터 (Cluster)**
  - 컨테이너를 실행하기 위한 논리적인 그룹 또는 가상의 공간
  - 클러스터 자체는 컴퓨팅 자원을 포함하지 않으며, 작업(Task)을 어디에서 실행할지 결정하는 경계 역할을 함
- **시작 유형 (Launch Type)** 클러스터 내에서 컨테이너를 실행할 기본 인프라를 결정하는 방식
  - **EC2**: 사용자가 직접 EC2 인스턴스(서버) 그룹을 프로비저닝하고 관리 서버의 종류, OS 등 세밀한 제어가 가능
  - **Fargate**: AWS가 서버 인프라를 완전히 관리하는 **서버리스** 방식 사용자는 EC2 인스턴스를 신경 쓸 필요 없이, 컨테이너에 필요한 CPU와 메모리만 지정하면 됨
- **작업 정의 (Task Definition)**
  - 애플리케이션을 구성하는 **컨테이너를 어떻게 실행할지에 대한 명세서 또는 설계도**
  - `docker-compose.yml` 파일과 유사한 역할
  - 주요 정의 내용:
    - 사용할 Docker 이미지 (ECR 또는 Docker Hub)
    - 컨테이너에 할당할 CPU 및 메모리
    - 컨테이너 시작 유형 (EC2/Fargate)
    - 포트 매핑, 환경 변수, 볼륨 마운트 등
- **작업 (Task)**
  - **작업 정의(설계도)에 따라 실제로 실행되는 컨테이너의 인스턴스**
  - 클러스터 내에서 실행되는 최소 단위이며, 고유한 네트워크 인터페이스(IP 주소)를 가짐
  - 쿠버네티스의 **Pod**와 유사한 개념
- **서비스 (Service)**
  - 클러스터 내에서 지정된 수의 **작업(Task)을 항상 실행하고 유지하는 역할**을 하는 관리자
  - 주요 기능:
    - **가용성 유지**: 특정 작업에 장애가 발생하면, 서비스가 이를 감지하고 자동으로 새로운 작업을 시작하여 원하는 작업 수를 유지
    - **로드 밸런싱**: Application Load Balancer(ALB)와 통합하여 여러 작업에 걸쳐 트래픽을 분산
    - **오토 스케일링**: CPU나 메모리 사용량에 따라 작업의 수를 자동으로 늘리거나 줄임
  - 쿠버네티스의 **Deployment**와 유사한 개념
- **ECR (Elastic Container Registry)**
  - Docker Hub와 유사한 AWS의 완전 관리형 컨테이너 이미지 레지스트리
  - ECS는 ECR과 완벽하게 통합되어, ECR에 저장된 프라이빗 이미지를 안전하고 빠르게 가져와 컨테이너를 실행할 수 있다

&nbsp;

## 3. ECS 배포 절차 요약 (Fargate 기준)

Fargate를 사용하면 EC2 인스턴스 관리 없이 아래의 간단한 절차만으로 애플리케이션 배포가 가능하다

1. **Docker Hub에 이미지 푸시**: 배포할 애플리케이션의 Docker 이미지를 빌드하여 Docker Hub와 같은 공개 레지스트리에 업로드
2. **클러스터 생성**: ECS에서 사용할 클러스터를 생성 (네트워킹 전용 - Fargate)
3. **작업 정의 생성**: Docker Hub에 있는 이미지를 사용하여 컨테이너 실행 방법(CPU, 메모리, 포트 등)을 정의
4. **서비스 생성**: 생성한 작업 정의를 사용하여 클러스터 내에서 작업을 실행하고 관리하는 서비스를 생성 이 단계에서 원하는 작업 수와 로드 밸런서 연결 등을 설정한다

&nbsp;

## 4. 실습: Nginx 웹 서버를 ECS Fargate로 배포하기

### 4-1. Docker Hub에 사용자 정의 이미지 푸시

기본 Nginx 이미지를 사용하는 대신, 원하는 내용을 표시하는 HTML 파일을 포함한 사용자 정의 이미지를 직접 빌드한다

1. **프로젝트 폴더 생성 및 파일 작성**:

   - 로컬 컴퓨터에 `nginx` 와 같은 이름의 폴더를 생성하고 해당 폴더로 이동

   - 이 폴더 안에 `index.html` 파일을 생성하고 아래와 같이 원하는 내용을 작성

     ```html
     <!DOCTYPE html>
     <html>
     <head>
         <meta charset="UTF-8">
         <title>ECS 배포 성공!</title>
     </head>
     <body>
         <h1>안녕하세요, 김민정님~!</h1>
         <p>ECS Fargate 배포에 성공했습니다.</p>
     </body>
     </html>
     ```

   - 같은 폴더 안에 `Dockerfile`을 생성하고 아래 내용을 작성

     ```dockerfile
     # Dockerfile
     # 공식 Nginx 이미지를 기반으로 시작
     FROM nginx:latest
     
     # 로컬의 index.html 파일을 컨테이너의 Nginx 웹 루트 디렉토리로 복사
     COPY ./index.html /usr/share/nginx/html/index.html
     ```

2. **Docker Hub 리포지토리 준비**:

   - Docker Hub에 로그인하여 이미지를 저장할 공개(Public) 리포지토리를 생성하거나 준비 (예: `my-custom-nginx-repo`)

3. **로컬에서 이미지 빌드 및 푸시**:

   - 로컬 터미널에서 `my-custom-nginx` 폴더로 이동한 후, 아래 명령어들을 실행하여 이미지를 빌드하고 푸시한다

     ```bash
     # 1. 멀티플랫폼 빌드를 위한 buildx 빌더를 생성하고 활성화합니다. (최초 1회만 실행)
     docker buildx create --use
     
     # 2. Docker Hub에 로그인 (이미 로그인 되어 있다면 생략 가능)
     docker login
     
     # 3. 여러 플랫폼(amd64, arm64)용 이미지를 동시에 빌드하고 바로 Docker Hub로 푸시합니다.
     docker buildx build --platform linux/amd64,linux/arm64 -t <자신의_DockerHub_ID>/my-custom-nginx-repo:latest . --push
     ```

<center><img src="https://image.minnnningnas.duckdns.org/images/8b3a6d0f-7ea3-4e38-82e0-136c1db60ffa.webp" style="zoom:50%;"></center>

> 위 방법으로 멀티플랫폼으로 빌드를 하지 않고 그냥 빌드를 한다면 배포 하면서 아래 오류 발생
>
> <center><img src="https://image.minnnningnas.duckdns.org/images/80572966-743e-4e14-95ee-336a3a085317.webp" style="zoom:50%;"></center>

### 4-2. ECS 클러스터 생성

1. **ECS 서비스로 이동**하여 '클러스터' 메뉴에서 '클러스터 생성' 클릭

   <center><img src="https://image.minnnningnas.duckdns.org/images/5faeb62a-1763-4e90-a786-885ee0b55f5a.webp" style="zoom:30%;"></center>

2. **클러스터 이름** (예: `my-fargate-cluster`)을 입력

3. **인프라** 섹션에서 **AWS Fargate(서버리스)**를 선택하고 '생성'
   <center><img src="https://image.minnnningnas.duckdns.org/images/a1f4bc04-d90b-4cad-9b03-3143fd3b8342.webp" style="zoom:30%;"></center>

   **생성 실패 오류**

   위 과정을 하면 실패하는 경우가 발생(Service-Linked Role 오류)
   <center><img src="https://image.minnnningnas.duckdns.org/images/b59047a1-f659-4b4e-994b-5c74f624a073.webp" style="zoom:50%;"></center>

   > **오류 상황**: 2단계에서 '생성' 버튼을 클릭했을 때, `Unable to assume the service linked role. Please verify that the ECS service linked role exists.` 와 유사한 오류가 발생
   >
   > **원인**: 이 오류는 AWS 계정에서 ECS 서비스가 다른 AWS 서비스(예: EC2, ELB)와 상호작용하는 데 필요한 권한(IAM 역할)이 없기 때문에 발생한다 이 역할은 **서비스 연결 역할(Service-Linked Role, SLR)**이라고 불리며, 보통은 ECS 클러스터를 처음 생성할 때 자동으로 만들어진다 하지만 간혹 권한 문제 등으로 자동 생성이 실패하면 이 오류가 나타남
   >
   > **해결 방법**: 필요한 서비스 연결 역할을 수동으로 생성해주면 간단히 해결된다
   >
   > 1. **AWS Management Console**에 로그인
   >
   > 2. 화면 상단 우측의 메뉴 바에서 **CloudShell 아이콘 (`>_`)**을 클릭
   >
   >    ```bash
   >    aws iam create-service-linked-role --aws-service-name ecs.amazonaws.com
   >    ```
   >
   >    결과, `An error occurred (InvalidInput) when calling the CreateServiceLinkedRole operation: Service role name AWSServiceRoleForECS has been taken in this account, please try a different suffix.` 첫번째 시도후 자동으로 만들어졌으니 다시 시도 해보면 된다
   >
   > 3. **재시도**: 위 명령이 성공적으로 실행된 후, 다시 AWS 콘솔로 돌아가 2단계의 클러스터 생성을 재시도하면 정상적으로 진행 이 작업은 AWS 계정당 한 번만 수행하면 된다

### 4-3. 작업 정의(Task Definition) 생성

1. ECS '작업 정의' 메뉴에서 '새 작업 정의 생성' 클릭

2. **작업 정의 이름** (예: `my-custom-nginx-task-def`)을 입력

3. **시작 유형**: **AWS Fargate** 선택

4. **작업 크기**: 작업에 할당할 **CPU(vCPU)**와 **메모리(GB)**를 지정. (예: 0.5 vCPU, 1 GB)

   <center><img src="https://image.minnnningnas.duckdns.org/images/8748504f-ca80-4205-864b-2e8b52ed4da6.webp" style="zoom:30%;"></center>

5. **컨테이너 세부 정보**:

   - **컨테이너 이름**: `my-custom-nginx-container`

   - **이미지 URI**: 1단계에서 Docker Hub에 푸시한 이미지의 URI를 입력 (예: `<자신의_DockerHub_ID>/my-custom-nginx-repo:latest`). 이미지가 공개(Public) 상태여야 함

   - **포트 매핑**: 호스트 포트는 비워두고, **컨테이너 포트**에 `80`을 입력
     <center><img src="https://image.minnnningnas.duckdns.org/images/baa0c8d7-e0f1-41ca-9eac-9c46afa49ee4.webp" style="zoom:30%;"></center>

### 4-4. 서비스(Service) 생성

1. 2단계에서 생성한 `my-fargate-cluster`를 클릭하고 '서비스' 탭에서 '생성' 클릭
2. **컴퓨팅 구성**: '시작 유형'이 **Fargate**로 선택되었는지 확인
3. **배포 구성**:
   - **패밀리**: 3단계에서 생성한 `my-custom-nginx-task-def`를 선택
   - **서비스 이름**: `my-custom-nginx-service`
   - **원하는 작업 수**: `2` (2개의 Nginx 컨테이너를 실행)
4. **네트워킹**:
   - **VPC 및 서브넷**: 사용할 VPC와 서브넷을 선택 (기본값 사용 가능)
   - **보안 그룹**: 80번 포트로의 인바운드 트래픽을 허용하는 보안 그룹을 생성하거나 선택
   - **로드 밸런싱**: 'Application Load Balancer'를 선택하고, 새 로드 밸런서를 생성하도록 설정. 리스너는 `HTTP:80`으로, 대상 그룹은 새로 생성하도록 설정

### 4-5. 배포 확인

- 서비스 생성이 완료되고 작업들이 `Running` 상태가 될 때까지 몇 분 정도 기다림

- EC2 서비스의 '로드 밸런서' 메뉴로 이동하여 방금 생성된 ALB를 찾고, **DNS 이름**을 복사
  <center><img src="https://image.minnnningnas.duckdns.org/images/c448c87c-b79d-42ee-8722-22c7e0ec6e5d.webp" style="zoom:50%;"></center>

- 웹 브라우저 주소창에 이 DNS 이름을 붙여넣으면, 직접 작성한 `index.html`의 내용이 표시됨

<center><img src="https://image.minnnningnas.duckdns.org/images/a7955af3-38ec-4fbe-922f-50e7f902ee52.webp" style="zoom:50%;"></center>
