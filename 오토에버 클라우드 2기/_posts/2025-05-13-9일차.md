---
layout: post
title: 오토에버 클라우드 2기 9일차
tags: DB nosql mongoDB
---

### 데이터 베이스 상태 조회 명령어

- db.getCollectionInfos(): 현재 데이터베이스의 collection들의 정보조회
- db.serverStatus(): 서버 정보 반환
- db.stats(): 통계정보

&nbsp;

### Collection 명령어

- show collections: 컬랙션 조회
- db.createCollection('이름',{capped:true,size:크기}): capped collection 생성 크기가 고정되서 넘어가면 오래된것부터 제거
- db.컬렉션이름.stats(): 컬렉션 정보
- db.컬렉션이름.latencyStatus(): 지연시간 확인
- db.컬렉션이름.storageSize(): 해당 컬렉션이 차지하는 실제 스토리지 공간을 반환
- db.컬렉션이름.totalIndexSize(): 해당 컬렉션의 모든 인덱스가 차지하는 공간 크기를 반환
- db.컬렉션이름.totalSize(): 컬렉션과 그에 속한 모든 인덱스가 차지하는 전체 공간을 반환 storageSize + totalIndexSize

&nbsp;

### 데이터 조회

- db.컬렉션이름.find(): 해당 컬렉션의 전체 데이터 조회

&nbsp;

### 도큐먼트 생성

- 단일 collection 대상으로 수행
- json표현식으로 데이터를 만들어서 삽입
- collection을 만들고 삽입 또는 없는 상태에서 삽입하면 자동으로 collection생성됨
- 도큐먼트를 만들때 _id라는 key를 만들지 않으면 자동으로 키 생성
- 함수 insert(deprecated), save(동일한 id가 존재하면 해당 데이터 수정), insertOne, insertMany



#### ObjectId

몽고디비에서는 12byte로 구성된 ObjectId를 제공한다 컬렉션을 만들면 _id라는 속성으로 ObjectId를 생성해서 할당하는 방식

`let newId = new ObjectId()`를 통해서 직접 생성하고 `db.smaple.insert({_id:newId, name:'new'})`이렇게 생성후 직접 사용 가능

&nbsp;

#### writeConcern

삽입, 삭제, 갱신하는 명령어는 writeConcern 옵션을 제공하는데 이 옵션은 데이터 손실을 방지하지하기 위한 옵션이다 일반적으로 삽입, 삭제, 갱신 명령은 저장 장치에 바로 명령을  수행하는것이 아니라 메모리에 작업을 수행한 후 나중에 결과를 저장장치에 반영한다 이 경우 데이터베이스에 문제가 생기면 메모리에만 저장된 데이터를 잃어버린 수 있는데 이를 방지하기 위한 옵션

&nbsp;

주요 옵션
- w (Write Acknowledgment Level)
  - 쓰기 작업이 몇 개의 노드에서 확인되어야 하는지를 지정합니다.
  - "majority": 레플리카 셋의 과반수 노드에서 쓰기가 확인되어야 함.
  - 숫자 값 (1, 2 등): 지정된 개수의 노드에서 쓰기가 확인되어야 함.
  - "0": 확인 없이 즉시 성공으로 간주.
- j (Journal Acknowledgment)
  - true로 설정하면, 쓰기 작업이 디스크의 **저널(journal)**에 기록될 때까지 기다립니다.
  - false로 설정하면, 저널 기록 없이 쓰기 작업이 완료된 것으로 간주됩니다.
- wtimeout (Write Timeout)
  - 지정된 시간(밀리초) 내에 w 조건을 만족하지 못하면 쓰기 작업이 실패합니다.
  - 예: wtimeout: 1000 → 1초 내에 쓰기 확인이 이루어지지 않으면 실패 처리.

``` js
db.collection.insertOne(
  { name: "MongoDB", type: "Database" },
  { writeConcern: { w: "majority", j: true, wtimeout: 5000 } }
);
```

위 설정은 과반수 노드에서 확인되고, 저널에 기록되며, 5초 내에 완료되지 않으면 실패하는 조건을 적용

&nbsp;

#### 자바스크립트 구문 사용가능

``` js
let num = 1;
for (let i = 0; i<3; i++){db.sample.insertOne({name:'user'+ i,score:num})};
```

&nbsp;

### 데이터 조회

단일 collection에서 도큐먼틀를 선택할 수 있다

cursor: 결과를 가지고 하나씩 접근할 수 있도록 해주는 객체

 find(query,projection): 데이터조회 projection은 컬럼 단위 추출 조건이 없으면 **전체**
ex) `db.container.find({name:'hi'})`
find(,{컬럼이름:true or 1}) 1이나 true로 설정하면 보이고 0이나 false면 안보임

&nbsp;

### 데이터 수정

``` js
db.collection.replaceOne(
    <query>,
    <replacement>,
    {
    	upsert: <boolean>,
    	collation: <document>
    }
)
```

- query는 수정할 데이터를 추출할 쿼리
- replacement 는 수정할 내용
- upsert는 조건에 맞는 데이터가 없는 경우 추가 여부
- collation는 악센트나 대소문자 관계에 대한 순서를 설정



#### updateOne, updateMany

비슷한 형태로 조건에 맞는 데이터가 여러개라도 1개만 수정한다

이 함수들은 $set연산자을 이용해서 수정할 내용을 작성한다

##### 파라미터, 연산자

- $addToSet: 배열안에 해당 값이 없다면 추가하고 있따면 추가하지 않는다
- $pop: 배열안의 첫번째 혹은 마지막 요소 제거
- $pull: 쿼리에 해당하는 요소 하나를 제거
- $push: 해당 요소를 배열에 추가
- $pullall: 해당하는 값을 가진 요소 전부를 제거

&nbsp;

### 데이터 삭제

- deleteOne(query,{option})
- dledteMany(query,{option})



&nbsp;

### Cursor

질의에 대한 포인더 몽고디비는 find의 결과로 커서를 리턴한다 커서는 쿼리 결과를 순차적으로 순회하기 위한 객체고 그 결과를 한 번에 모두 가져오는 것이 아니라, **필요할 때마다 하나씩 가져올 수 있도록 만들어진 "결과 집합의 포인터"**이다 

문서를 필요한 만큼만 가져오기 때문에 메모리 효율성이 좋아진다

&nbsp;

### 파이썬 db연결하기

`pip install pymogno` 패키지 설치

``` python
from pymongo import MongoClient

# db서버 연결
con = MongoClient('127.0.0.1',27017)

#데이터베이스 연결
db = con.adam

#collection 연결
users = db.users

doc1 = {'empno':1001,'name':'ask'}
doc2 = {'empno':1002,'name':'ask1'}
doc3 = {'empno':1003,'name':'ask2'}
doc4 = {'empno':1004,'name':'ask3'}
doc5 = {'empno':1005,'name':'ask4'}

users.insert_one(doc1)
users.insert_many([doc2,doc3,doc4,doc5])


```

데이터 추가전 

<center>
<img src="https://github.com/user-attachments/assets/71588995-aef7-4ee6-9c71-9b6f8f378dcc" style="zoom:80%;">
</center>

추가후
<center>
<img src="https://github.com/user-attachments/assets/fbc20b1a-f691-4beb-bca9-e6733182dc19" style="zoom:80%;">
</center>

adam db가 생성된고 users컬렉션에 데이터가 5개 들어간것을 확인할 수 있다

`print(users.count_documents({}))`를 데이터 생성후 코드를 실행하면 5를 출력한다

``` py
print(users.find())
 # <pymongo.synchronous.cursor.Cursor object at 0x00000235B06CE510>

print(users.find_one())
# {'_id': ObjectId('682301b9f0647dde384f15fa'), 'empno': 1001, 'name': 'ask'}

cursor = users.find()
print(dir(cursor))
print(type(cursor))
#<class 'pymongo.synchronous.cursor.Cursor'>
```

find() 여러게 반환할때는 뭔가 다름 타입을 보면 cursor타입

dir결과를 보면 iter를 표시하고 있어서 for를 사용

``` py
for data in cursor:
    print(data)

#{'_id': ObjectId('682301b9f0647dde384f15fa'), 'empno': 1001, 'name': 'ask'}
#{'_id': ObjectId('682301b9f0647dde384f15fb'), 'empno': 1002, 'name': 'ask1'}
#{'_id': ObjectId('682301b9f0647dde384f15fc'), 'empno': 1003, 'name': 'ask2'}
#{'_id': ObjectId('682301b9f0647dde384f15fd'), 'empno': 1004, 'name': 'ask3'}
#{'_id': ObjectId('682301b9f0647dde384f15fe'), 'empno': 1005, 'name': 'ask4'}
```

여러개 담긴 상태라 처음에 주소를 반환했던것이다

