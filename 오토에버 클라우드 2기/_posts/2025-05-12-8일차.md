---
layout: post
title: 오토에버 클라우드 2기 8일차
tags: DB mariaDB sql nosql mongoDB
---

제약조건에 이름을 붙일 수 있는데 `constriaint`를 이용하면 된다

``` sql
CREATE TABLE Employees (
    EmployeeID INT PRIMARY KEY,
    Name VARCHAR(100) NOT NULL,
    Age INT CHECK (Age >= 18),
    DepartmentID INT REFERENCES Departments(DepartmentID)
); 
```

위 코드는 이름 없이 제약조건을 사용한 경우고

``` sql
CREATE TABLE Employees (
    EmployeeID INT PRIMARY KEY,
    Name VARCHAR(100) NOT NULL,
    Age INT CHECK (Age >= 18),
    DepartmentID INT,
    CONSTRAINT fk_department FOREIGN KEY (DepartmentID) REFERENCES Departments(DepartmentID)
);
```

위 코드처럼 이름을 생성할 수 도 있다 그렇다면 이름은 왜 사용할까?

이름이 있다면 수정,삭제가 더 편리하다고 한다

`ALTER TABLE Employees DROP CONSTRAINT fk_department;` 이름이 있는 경우

``` sql
SELECT CONSTRAINT_NAME
FROM INFORMATION_SCHEMA.TABLE_CONSTRAINTS
WHERE TABLE_NAME = 'Employees' AND CONSTRAINT_TYPE = 'FOREIGN KEY';
```

위 명령어로 자동 생성된 제약 조건 이름 조회, 위 코드를 실행했을때 나오는 이름은 `employees_ibfk_1`

``` SQL
ALTER TABLE Employees DROP CONSTRAINT 자동생성된_이름;
```

제약 조건을 변경해 본 적이 없어서 이름이 없을 때 번거롭다고 느끼지 못해서 constriaint가 필요한가?라고 생각 했지만 프로젝트가 크거나 회사에서는 무조건 사용할 것 같다

&nbsp;

### DML(데이터 조작 언어)

이론에서는 SELECT, INSERT, DELETE, UPDATE 4가지를 DML로 보지만 실무에서는 SELECT를 DQL(DATA QUERY LANGUAGE)로 구분한다

#### INSERT
새로운 데이터를 테이블에 추가할 때 사용한다

``` SQL
INSERT INTO employees (id, name, age, department)
VALUES (101, '김철수', 30, '마케팅');
```

전체 필드를 다 채운다면 컬럼 이름 생략가능

#### UPDATE

데이터 수정시 사용 

``` SQL
UPDATE employees
SET age = 31
WHERE id = 101;
```

 id가 101인 직원의 나이를 31로 수정하는 명령어

#### DELETE

데이터 삭제시 사용( where 조건이 없다면 모든 데이터를 삭제)

``` SQL
DELETE FROM employees
WHERE id = 101;
```

id가 101인 데이터를 삭제한다

&nbsp;

#### SELECT 구문을 이용해서 테이블 생성

``` sql
CREATE TABLE new_employees AS
SELECT * FROM employees
WHERE 0=1;
```

where에 거짓 조건을 넣으면 전체 데이터가 복사가 되고 특정 조건을 넣으면 해당 조건을 만족하는 데이터만 복사된다

*기존 테이블과 동일한 컬럼을 포함하지만, 제약 조건(Primary Key, Index 등)은 복사되지 않는다*

&nbsp;

### 트랜잭션

한번에 수행되어야 하는 논리적 작업 처리 단위, 물리적인 작업 처리 단위는 sql 문장

트랜잭션의 성질 4가지

- 원자성: 하나의 트랜잭션은 전부 처리하던지 하나도 처리를 하지 않아야 한다
- 일관성: 트랜잭션이 실행을 성공적으로 완료하면 언제나 일관성 있는 상태를 유지해야 한다
- 독립성: 트랜잭션을 수행시 다른 트랜잭션의 연산 작업이 끼어들지 못하게 보장하는 것
- 영속성: 성공적으로 수행된 트랜잭션은 영원히 반영되어야 한다

&nbsp;

#### TCL

1. Commit : 현재 트랜잭션을 완료
2. SavePoint : 중간 저장점 생성
3. Rollback : 현재 트랜잭션을 취소하거나 중간 저장점으로 돌아가는 명령

&nbsp;

## MongoDB

몽고 디비는 자바 기반의 클라우드 플랫폼을 위한 컴포넌트로 개발, 크로스 플랫폼 도큐먼트 지향 nosql 데이터베이스 시스템

**스키마 생성없이 데이터 저장이 가능**

nosql은 대부분 키,벨류로 되어있고 키값이 고정되어있지 않다 따라서 스키마가 필요없다

데이터 형식은 json으로 java script object notation

&nbsp;

### RDBMS와 차이

- database &rarr; database
- table &rarr; collection 몽고디비에서는 조인이 없어서 데이터를 모아서 저장하지만 그러면 느려짐
- row &rarr; document
- column &rarr; field
- index &rarr; index
- join &rarr; embedding & linking
- 조회의 결과는 row의 집합 &rarr; cursor

&nbsp;

### 명령어

`show dbs` db목록을 보여준다

`use dbname` 입력한 이름의 db를 사용 없다면 db생성

`db`현재 db확인

&nbsp;

`db.createCollection('컬렉션 이름')` 컬렉션 생성

`db.getCollectionNames()` 모든 컬렉션 조회

`db.컬렉션이름.drop()`컬렉션 제거

`db.컬렉션이름.renameCollection(변경할이름)` 컬렉션 이름 변경

**capped collection** 정해진 크기를 초과하면 자동으로 가장 오래된 데이터를 삭제, 로그,cctv

`db.createCollection('컬렉션이름,{capped: true, size: 크기}')`

