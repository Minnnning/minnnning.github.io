---
layout: post
title: 오토에버 클라우드 2기 58일차
tags: aws 스토리지 s3
---

## AWS의 데이터 스토리지 및 데이터베이스 서비스

클라우드 환경에서는 데이터를 저장하고 관리하는 방식이 매우 다양함 애플리케이션의 특성에 맞는 최적의 서비스를 선택하기 위해서는 각 스토리지와 데이터베이스 유형의 근본적인 차이를 이해하는 것이 중요

### 1. 스토리지 유형의 이해: 블록, 파일, 오브젝트

AWS는 크게 세 가지 유형의 클라우드 스토리지를 제공한다

- **블록 스토리지 (Block Storage)**
  - **개념**: 데이터를 일정한 크기의 블록(Block) 단위로 나누어 저장하는 방식 각 블록은 고유한 주소를 가지며, 마치 하드 드라이브(HDD)나 SSD처럼 운영체제에 직접 연결하여 사용
  - **특징**: 매우 빠른 읽기/쓰기 속도(낮은 지연 시간)를 제공하며, 데이터베이스나 고성능 컴퓨팅처럼 빠른 I/O가 필수적인 워크로드에 적합
  - **AWS 서비스**: `Amazon EBS (Elastic Block Store)` - EC2 인스턴스의 주 하드 드라이브로 사용됨
- **파일 스토리지 (File Storage)**
  - **개념**: 우리가 일반적으로 사용하는 컴퓨터의 파일 시스템처럼, 데이터를 폴더와 파일의 계층 구조로 저장하고 관리
  - **특징**: 여러 사용자와 시스템이 동시에 파일에 접근하고 공유하기 용이 NFS나 SMB와 같은 표준 파일 공유 프로토콜을 사용
  - **AWS 서비스**: `Amazon EFS (Elastic File System)` - 여러 EC2 인스턴스에서 동시에 마운트하여 사용할 수 있는 공유 파일 시스템
- **오브젝트 스토리지 (Object Storage)**
  - **개념**: 파일 데이터 자체와 관련 메타데이터를 하나의 단위인 **객체(Object)**로 묶어, 고유한 ID(Key)와 함께 거대한 저장 공간(버킷)에 저장하는 방식 계층 구조가 없는 평면적인 구조를 가짐
  - **특징**: HTTP/HTTPS 프로토콜을 통해 웹에서 쉽게 접근 가능하며, 사실상 무한한 확장성과 매우 높은 내구성을 제공 대용량 데이터(이미지, 동영상, 로그, 백업) 저장에 최적화되어 있음
  - **AWS 서비스**: `Amazon S3 (Simple Storage Service)`

&nbsp;

### 2. 데이터베이스와 스토리지의 차이점

| 구분            | 스토리지 (Storage)                                    | 데이터베이스 (Database)                                      |
| --------------- | ----------------------------------------------------- | ------------------------------------------------------------ |
| **핵심 목적**   | 파일/데이터 덩어리 자체의 **보관, 검색, 전송**        | 구조화된 데이터의 **효율적인 관리, 검색, 수정, 트랜잭션 처리** |
| **데이터 구조** | 비구조적. 파일, 블록, 객체 등 데이터 원형 그대로 저장 | 구조적. 정해진 스키마(테이블, 문서 등)에 따라 데이터를 체계적으로 저장 |
| **주요 기능**   | 데이터의 저장 및 검색 (CRUD)                          | 데이터의 CRUD는 물론, 복잡한 쿼리, 인덱싱, 관계 설정, 트랜잭션 보장 등 |
| **접근 방식**   | 파일 시스템 API, 블록 I/O, HTTP API                   | SQL, NoSQL 등 특정 쿼리 언어를 통해 접근                     |
| **적합한 용도** | 이미지, 동영상, 로그, 백업 파일, OS 디스크 등         | 사용자 정보, 상품 목록, 거래 내역, 세션 데이터 등            |

간단히 말해, **스토리지**는 '파일 캐비닛'처럼 파일 자체를 보관하는 창고의 역할이며, **데이터베이스**는 '도서관의 색인 카드 시스템'처럼 보관된 데이터의 내용을 체계적으로 관리하고 빠르게 찾아주는 시스템의 역할

&nbsp;

### 3. AWS의 목적별 데이터베이스 서비스 종류

애플리케이션의 특성과 요구사항에 맞는 데이터베이스를 선택하는 것은 매우 중요 AWS는 다양한 유형의 데이터 저장소를 완전 관리형 서비스로 제공한다

- **관계형 데이터베이스 (RDBMS)**: 정형화된 데이터를 테이블 형태로 저장 (예: `Amazon RDS`, `Amazon Aurora`)
- **키-값 데이터베이스 (Key-Value DB)**: 고유한 키(Key)에 값(Value)을 저장하는 단순한 구조로, 매우 빠른 읽기/쓰기 속도를 제공 (예: `Amazon DynamoDB`)
- **인메모리 데이터베이스 (In-Memory DB)**: 데이터를 디스크가 아닌 메모리에 저장하여 응답 속도를 극대화 캐싱, 세션 관리에 주로 사용 (예: `Amazon ElastiCache`)
- **도큐먼트 데이터베이스 (Document DB)**: JSON과 유사한 유연한 문서 형태로 데이터를 저장 (예: `Amazon DocumentDB`)
- **와이드 컬럼 스토어 (Wide Column)**: 대규모 데이터셋에 대한 빠른 분석 및 쿼리에 최적화된 열(Column) 기반 저장 방식 (예: `Amazon Keyspaces`)
- **그래프 데이터베이스 (Graph DB)**: 데이터 간의 관계를 그래프 형태로 저장하여, 관계 분석 및 추천 엔진 등에 활용 (예: `Amazon Neptune`)
- **시계열 데이터베이스 (Time Series DB)**: 시간에 따른 데이터의 변화를 효율적으로 저장하고 분석한다 IoT 센서 데이터, DevOps 메트릭 등에 사용 (예: `Amazon Timestream`)
- **원장 데이터베이스 (Ledger DB)**: 모든 변경 내역을 추적하고 검증할 수 있는 불변의 거래 원장을 저장 공급망, 금융 거래에 활용 (예: `Amazon QLDB`)

&nbsp;

### 4. 관계형 데이터베이스 서비스 (Amazon RDS)

Amazon RDS는 클라우드에서 관계형 데이터베이스를 간편하게 설정, 운영 및 확장할 수 있는 완전 관리형 서비스임

- **장점**:
  - **관리형 서비스**: OS 패치, 데이터베이스 업데이트, 백업 등 번거로운 관리 작업을 AWS가 자동으로 수행
  - **간편한 구성 및 이전**: 몇 번의 클릭만으로 데이터베이스를 생성할 수 있으며, 기존 온프레미스 환경의 데이터를 쉽게 이전 가능
  - **쉬운 연동**: EC2 인스턴스와 같은 VPC 내에서 통신 시 요금이 부과되지 않음
- **단점**:
  - 완전 관리형 서비스이므로, 사용자가 OS에 직접 접근하거나 세부적인 설정을 자유롭게 변경하는 데 제약이 있다

&nbsp;

### 3.5. RDS vs. EC2에 직접 설치: 차이점 비교

| 항목                 | Amazon RDS (관리형 서비스)                                   | EC2에 직접 설치 (비관리형)                                   |
| -------------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| **관리 부담**        | **낮다** OS/DB 패치, 백업, 고가용성 구성 등을 AWS가 자동 관리 | **높다** 사용자가 OS, DB 설치, 패치, 백업, 모니터링 등 모든 것을 직접 관리 |
| **유연성 및 제어**   | **제한적** OS에 접근 불가 정해진 파라미터 그룹 내에서만 DB 설정 변경 가능 | **매우 높음** OS에 대한 전체 제어권(root 접근)을 가지며, DB의 모든 설정을 자유롭게 변경 가능 |
| **비용**             | **초기 비용 낮음, 장기적으로 더 높을 수 있음** 관리 편의성에 대한 비용이 포함됨 | **초기 비용 높을 수 있음, 장기적으로 저렴할 수 있음**. 인스턴스 비용만 발생하지만, 관리 인력/시간 비용을 고려해야 함 |
| **고가용성/백업**    | **간편함** 몇 번의 클릭으로 다중 AZ(Multi-AZ) 구성 및 자동 백업/시점 복구 설정 가능 | **복잡함** 사용자가 직접 Replication 구성, 백업 스크립트 작성 및 스케줄링 등 모든 것을 수동으로 구현 |
| **확장성**           | **간편함** 콘솔에서 인스턴스 사양 변경(스케일업)이나 읽기 전용 복제본(Read Replica) 추가(스케일아웃)가 용이 | **수동 작업 필요** 인스턴스 타입을 변경하거나, 복제본을 직접 구성하고 추가해야 함 |
| **적합한 사용 사례** | - DB 관리 전문 인력이 부족한 경우<br>- 빠르고 안정적인 DB 구축이 필요한 경우<br>- 표준적인 DB 환경으로 충분한 경우 | - DB의 특정 버전이나 확장 기능이 반드시 필요한 경우<br>- OS 수준의 완전한 제어권이 필요한 경우<br>- 비용을 최소화하고 모든 것을 직접 제어하려는 경우 |

&nbsp;

## AWS의 파일 및 오브젝트 스토리지 활용

### 1. AWS를 이용한 백업 전략

- **온프레미스 데이터 백업**: 스토리지 게이트웨이(Storage Gateway)를 사용하거나, S3 CLI를 통해 온프레미스 데이터를 S3에 직접 백업
- **수명 주기 관리**: S3의 수명 주기 규칙을 사용하여, 오래된 데이터를 저렴한 스토리지 클래스(예: S3 Glacier)로 자동으로 이동시켜 비용 절감
- **대용량 파일 백업**: 용량이 큰 이미지나 데이터베이스 파일은 스크립트를 사용하여 S3에 직접 백업하는 것이 비용 효율적

### 2. 오브젝트 스토리지 (Amazon S3)

Amazon S3(Simple Storage Service)는 인터넷을 위한 스토리지 서비스로, 용량에 관계없이 파일을 저장하고 웹에서 접근할 수 있음

- **기본 개념**:
  - **객체(Object)**: S3에 저장되는 기본 단위로, 파일 데이터와 메타데이터로 구성
  - **버킷(Bucket)**: 객체를 저장하는 최상위 디렉토리. 버킷 이름은 전 세계에서 유일해야 함
- **장점**:
  - **무한한 확장성**: 저장 용량과 객체 수에 제한이 없음
  - **높은 내구성 및 가용성**: 99.999999999%의 내구성을 보장하여 데이터 유실 가능성이 거의 없음
  - **정적 웹 호스팅**: 버킷 자체를 정적 웹사이트로 서비스할 수 있음

### 3. 실습: S3 버킷 생성 및 권한 설정

1. **IAM 사용자 생성 및 액세스 키 발급** (외부 애플리케이션 연동 시)

   - IAM 서비스에서 '사용자 생성'
   - 사용자에게 `AmazonS3FullAccess`와 같은 적절한 권한 정책을 직접 연결
   - 생성 후 '보안 자격 증명' 탭에서 **액세스 키**를 생성하고, `.csv` 파일을 다운로드하여 안전하게 보관. (이 키는 한 번만 확인 가능)

2. **S3 버킷 생성**

   - S3 서비스에서 '버킷 만들기' 클릭.
   - 버킷 이름은 전 세계에서 고유해야 함
   - 리전 선택
   - **객체 소유권**: 'ACL 활성화됨' 선택
   - **퍼블릭 액세스 차단 설정**: 모든 퍼블릭 액세스를 차단 해제 (외부 공개 시)

3. **버킷 권한 설정** 생성된 버킷의 '권한' 탭에서 외부 접근을 위한 정책을 설정

   - **버킷 정책 (Bucket Policy) 상세 설명**: JSON 형식으로 "누가(Principal), 어떤 리소스(Resource)에 대해, 어떤 조건(Condition)에서, 어떤 작업(Action)을, 허용(Allow) 또는 거부(Deny)할 것인가"를 명시하는 규칙

     ```json
     {
         // 정책 언어의 버전을 지정. "2012-10-17"은 현재 권장되는 최신 버전임.
         "Version": "2012-10-17",
         // 실제 권한 규칙을 정의하는 하나 이상의 명령문(Statement) 배열.
         "Statement": [
             {
                 // 각 명령문을 식별하기 위한 고유한 이름 (선택 사항).
                 "Sid": "PublicAccess",
                 // 이 정책의 효과를 지정. 'Allow'(허용) 또는 'Deny'(거부)가 있음.
                 "Effect": "Allow",
                 // 이 정책의 영향을 받는 대상(주체). "*"는 인증 여부와 관계없이 '모든 사용자'를 의미함.
                 // 주의: 이는 버킷을 완전히 공개하는 설정이므로, 민감한 데이터에는 사용하면 안 됨.
                 "Principal": "*",
                 // 허용하거나 거부할 작업의 목록.
                 "Action": [
                     "s3:GetObject",     // 객체(파일)를 다운로드할 권한
                     "s3:PutObject",     // 객체를 업로드/덮어쓸 권한
                     "s3:DeleteObject",  // 객체를 삭제할 권한
                     "s3:ListBucket"     // 버킷 내의 객체 목록을 볼 권한
                 ],
                 // 이 정책이 적용될 자원(버킷 또는 객체)을 ARN(Amazon Resource Name)으로 지정.
                 "Resource": [
                     "arn:aws:s3:::<버킷이름>",      // 버킷 자체에 대한 권한 (ListBucket 등)
                     "arn:aws:s3:::<버킷이름>/*"   // 버킷 내의 모든 객체에 대한 권한 (GetObject, PutObject 등)
                 ]
             }
         ]
     }
     ```

   - **CORS(Cross-Origin Resource Sharing) 설정**: 다른 도메인의 웹 애플리케이션(예: `http://localhost:3000`)에서 이 버킷의 리소스에 접근할 수 있도록 허용하는 규칙

     ```json
     [
         {
             "AllowedHeaders": ["*"],
             "AllowedMethods": ["GET", "PUT", "POST", "DELETE"],
             "AllowedOrigins": ["*"],
             "ExposeHeaders": []
         }
     ]
     ```

이제 버킷에 파일을 업로드하고, 각 객체의 URL을 통해 웹에서 직접 접근할 수 있음
