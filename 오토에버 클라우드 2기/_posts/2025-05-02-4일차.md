---
layout: post
title: 오토에버 클라우드 2기 4일차
tags: PYTHON mvc web
excerpt_image: "https://github.com/user-attachments/assets/f8ec3451-e7ca-4556-9817-a95a263a737a"
---

list와 tuple은 데이터를 나누어서 저장하는 것이 가능하다 데이터를 나눌 때 `*`를 사용하면 `*`이 없는 곳에 list로 나누어 준다

``` py
tu = (1,2,3)
a,b,c = tu
print(c) # 3

# 대입하지 않을 데이터는 _로 매칭
a,b,_ = tu
print(b) # 2

# *은 나머지 전부
a,*b = tu
print(b) # [2,3]
```

&nbsp;

#### Tuple을 이용한 조건문

``` py
score = 60
# 60 이상인 경우 합격
print(('불합격','합격')[score>=60])
#       거짓 , 참
```

&nbsp;

#### collections 모듈의  namedtuple

namedtuple함수를 이용하면 필드명과 클래스 이름을 추가한 서브 클래스를 생성한다 이 자료형을 만들어진 튜플은 이름을 이용해서 접근이 가능하다

첫번째 매개변수로 이 클래스의 설명을 넣고 두번째 매개변수로 문자열로 필드명을 공백과 함께 나열

``` py
from collections import namedtuple
VO = namedtuple("VO","num name age") # 필드명 나열
vo = VO(1,'김민정',14)

print(vo.num)
```

&nbsp;

#### Dict

딕셔너리는 key value형태이며 값을 얻기 위해서는 a[key]또는 a.get(key,기본값)

기존 리스트나 튜플 set을 이용해서 딕셔너리를 만들 수 있는데

`dict(zip(ket집합,value집합))`

keys,values,items 메서드 이용시 튜플로 리턴

pop을 이용해서 마지막 하나의 데이터를 반환하고 제거

&nbsp;

#### enumerate

인덱스와 데이터를 하나의 튜플로 리턴해 주는 함수

&nbsp;

#### collections모듈의 counter

갯수 셀 때 유용함

&nbsp;

### 모듈 sys

``` py
import sys
print(f"현재 인코딩 방식:{sys.getdefaultencoding}")
#현재 인코딩 방식:<built-in function getdefaultencoding>

a = "hello"
b = 3

print(f"{a}의 참조 횟수 : {sys.getrefcount(a)}")
#hello의 참조 횟수 : 5
print(f"현재 로딩된 모듈: {sys.modules}")
#현재 로딩된 모듈: {'sys': <module 'sys' (built-in)>, 'builtins': <module 'builtins' (built-in)>, '_frozen_importlib': <module '_frozen_importlib' (frozen)>, '_imp': <module '_imp' (built-in)>, '_thread': <module '_thread' (built-in)>, '_warnings': <module '_warnings' (built-in)>, '_weakref': <module '_weakref' (built-in)>, '_io': <module '_io' (built-in)>, 'marshal': <module 'marshal' (built-in)>, 'posix': <module 'posix' (built-in)><... 중략 ...>}
```

&nbsp;

### MVC 패턴

* model: 실제 비지니스 로직
* view: 화면에 보여지는 부분
* controller: 둘 사이를 연결해 주는 부분

이 부분을 나누어서 구현하고 하나의 변화가 다른 하나에 영향을 거의 미지치 않도록 하는 프로그래밍 방식

&nbsp;

### WEB 프로그래밍

### ✅ 1. GET

- **용도**: 서버로부터 데이터를 조회할 때 사용
- **특징**
  - 쿼리스트링(`?key=value`)을 통해 데이터 전달
  - 서버의 데이터를 **가져오기만** 함 (변경 없음)
  - 브라우저 캐싱 가능

### ✅ 2. POST

- **용도**: 서버에 **새로운 데이터 생성** 또는 복잡한 작업 요청
- **특징**
- 데이터는 **HTTP 본문(body)** 에 포함됨
- 주로 폼 제출, 파일 업로드 등에 사용
- 서버 상태를 변경함

### ✅ 3. PUT

- **용도**: **기존 리소스를 전체 수정**할 때 사용
- **특징**
- 데이터는 body에 포함
- 동일한 요청을 반복해도 결과는 같음 (멱등성 있음)
- 보통 리소스의 전체 속성을 포함해야 함

### ✅ 4. DELETE

- **용도**: 서버에 있는 리소스를 **삭제**할 때 사용
- **특징**
- 주로 리소스 식별자는 URL에 포함
- 멱등성 있음 (같은 요청 반복해도 결과 같음)
- 보안상 인증/인가 필요

&nbsp;

| 메서드 | 목적           | 본문 사용 | 멱등성 | 주 용도             |
| ------ | -------------- | --------- | ------ | ------------------- |
| GET    | 조회           | ❌         | ✅      | 데이터 가져오기     |
| POST   | 생성/작업 요청 | ✅         | ❌      | 데이터 생성, 업로드 |
| PUT    | 전체 수정      | ✅         | ✅      | 전체 정보 변경      |
| DELETE | 삭제           | 보통 ❌    | ✅      | 리소스 삭제         |

&nbsp;

포워딩(Forwarding)과 리다이렉션(Redirection)은 웹에서 요청을 다른 위치로 이동시키는 방식이다
- 포워딩 (Forwarding)
  - 서버 내부에서 처리되며, 클라이언트가 변경을 인식하지 못합니다.
  - 웹 애플리케이션 내에서 특정 페이지 요청을 다른 페이지로 전달하는 방식입니다.
  - 현재 요청을 유지한 채 페이지 이동을 수행합니다.
  - URL이 변경되지 않으며, 사용자는 현재 페이지에서 다른 콘텐츠를 보게 됩니다.
  - 예: 이전 요청을 가지고 있다 검색을 하고 검색 결과 페이지에서 새로고침을 하면 주소가 똑같은 페이지를 봄
- 리다이렉션 (Redirection)
  - 클라이언트에게 새로운 URL로 이동하도록 지시합니다.
  - 브라우저가 새로운 요청을 보내므로 URL이 변경됩니다.
  - 예: 로그인 페이지에서 로그인을 하면 다른 페이지로 이동

즉, 포워딩은 서버 내부에서 페이지를 변경하는 것이고, 리다이렉션은 클라이언트에게 새로운 페이지로 이동하도록 요청하는 방식

웹 프로그래밍을 하면서 포워딩과 리다이렉션을 구분해서 생각해본적이 없었는데 이 두개의 차이점을 알게 되었다

&nbsp;

### Fast API

`pip3 install fastapi uvicorn`으로 설치

실행할 위치에 main.py를 생성해야한다

``` py
from fastapi import FastAPI
app = FastAPI()

# 처리할 url
@app.get("/")
def welcome() -> dict:
    return {"message":"안녕하세요"}
```

`uvicorn main:인스턴스 이름 --host ip주소 --port 포트번호 --reload`

--reload 코드를 수정하면 재실행

`uvicorn main:app --host 127.0.0.1 --port 8001 --reload`

<center>
<img src="https://github.com/user-attachments/assets/f8ec3451-e7ca-4556-9817-a95a263a737a" style="zoom:50%;">
</center>


&nbsp;

