학교에서 하는 자료구조 수업에서 c언어를 이용하기 때문에 잊어버린 c언어의 기초를 다시 정리해야한다

&nbsp;

### 자료형

자료형에는 크게 3가지가 있다

|    정수형     | short,  int, long, long long |
| :-----------: | :--------------------------: |
| 부동 소수점형 |  float, double, long double  |
|    문자형     |             char             |

&nbsp;

#### 각각의 자료형에 따른 printf()

| 형식 지정자 | 의미             | 예                          |
| :---------: | ---------------- | --------------------------- |
|     %d      | 10진 정수로 출력 | printf("%d", x)             |
|     %f      | 실수로 출력      | printf("%f", x)             |
|     %c      | 문자 하나를 출력 | printf("%c", x)             |
|     %s      | 문자열을 출력    | char x[10]; printf("%s", x) |

&nbsp;

#### 자료형에 따른 입력 scanf_s()

| 형식 지정자 | 의미                     | 예                            |
| :---------: | ------------------------ | ----------------------------- |
|     %d      | 정수를 10진수로 입력한다 | scanf_s("%d", &x)             |
|     %f      | float형의 실수로 입력    | scanf_s("%f", &x)             |
|     %lf     | double형의 실수로 입력   | scanf_s("%lf", &x)            |
|     %c      | 문자 형태로 입력         | scanf_s("%c", &x)             |
|     %s      | 문자열 형태로 입력       | char x[10]; scanf_s("%s", ;x) |

&nbsp;

&nbsp;

### 함수의 구조

c언어는 메인함수와 다른 함수로 만들어져 있다

``` c
#include <stdio.h>
int main (void){
  return 0;
}
```

위는 기본적인 메인 함수로 다른 함수들을 메인 함수안에서 사용하는 형태로 프로그래밍한다 함수 맨 앞에는 리턴값의 형태(int)를 명시하고 두번째 main은 함수의 이름이된다 ()안의 값은 입력 값인데 값 입력이 없어서 void로 만들었다 ()가 함수라는 의미를 나타낸다 또한 main은 우리가 이름을 변경 할 수 없는 특별한 함수이다

&nbsp;

#### 함수

프로그래밍을 하다보면 함수를 많이 사용한다 위에서 설명한 메인함수와 똑같은 구조를 가졌지만 이름을 자유롭게 쓸 수 있다

``` c
#include <stdio.h>
int max(int x, int y) { //매개변수의 개수와 자료형을 나타냄
  if (x>y) {
    return x;
  } else {
    return y;
  }
}

int main (void) {
  int a,b,result;
  scanf_s("%d", &a);
  scanf_s("%d", &b);
  result = max(a,b); //함수 호출과 매개변수
  printf("큰수는 %d입니다", result); 
}
```

 &nbsp;

&nbsp;

### 포인터

c언어에서 가장 중요하고 어렵다고 생각하는 부분이다 포인터는 메모리의 주소를 가지는 변수이다 일단 메모리 주소부터 알아보면

` int i = 10;`으로 i라는 변수에 10을 저장한다고 하면 i는 변수의 이름이고 값은 메모리에 저장된다 메모리 저장 위치를 볼 수 있는데

`printf('i의 주소는 %u', &i)`주소연산자 &를 통해서 변수 i의 주소를 알 수 있다

&nbsp;

#### 포인터 선언

포인터는 변수의 **주소**를 값으로 가지고 있는 변수이다 

`int* p;` 포인터 변수의 자료형은 int형이다 주소는 한 가지 형식인데 자료형을 가지는 이유는 **포인터가 가리키는 대상의 자료형**을 정확하게 한다 

``` c
#include <stdio.h>

int main(void) {
    int i = 10; //변수 i에 10을 저장한다
    int *p; //포인터 변수 p를 선언 
    p = &i; //p의 값에는 i의 주소가 들어간다

    printf("%u\n",p); //p는 i의 주소를 가지고 있어서 주소를 출력한다
    printf("%u\n",&i); //i의 주소
    // 두 개의 결과 값은 같다 같은 값을 가지고 있음

    printf("%d\n",*p);
    //*를 통해서 p에 해당하는 주소에 저장된 값을 출력한다
    printf("%d\n", i);
    return 0;
}
```

<center>
<img src="https://user-images.githubusercontent.com/80758613/230293587-fb8786be-7541-46d1-a56d-9b73b2653ff8.png" style="zoom:60%;">
</center>&nbsp;

&nbsp;

위 코드에서 포인터 변수 p에는 **주소값**을 넣고 이 주소에 연결된 **값**을 출력할려면 *p를 출력하면된다

포인터는 주소를 이용한 연산을 할 수 있다 주소를 왜 이용할까?

그중 하나의 이유로는 마치 **전역 변수**처럼 사용할 수 있다 함수내에 변수를 선언하면 그 변수는 지역 변수로 함수 밖에서는 사용할 수 없다 그렇기 때문에 값을 리턴해서 함수의 결과값을 이용할 수 있는데 반환하는 값이 2개 이상이면 반환을 할 수 없다 (1개의 값만 반환 가능 배열에 저장해서 여러개의 값을 반환하는것도 가능하다 이또한 자료형이 다르면 안된다) 하지만 전역변수를 이용하면 함수안에서 했던 연산을 그대로 적용시킬 수 있다 그런데 전역변수를 남발하는것은 좋은 프로그램이 아니다 따라서 포인터나 구조체를 사용하면 된다

&nbsp;

포인터를 사용하면 주소에 접근해서 주소 안에 있는 값을 바꿀 수 있다-> **주소에 직접 접근해서 저장된 값을 바꾼다**

따라서 마치 전역 변수처럼 사용할 수 있다

``` c
#include <stdio.h>
void swap(int *x, int *y) {
  int temp;
  temp = *x;
  *x = *y;
  *y = temp;
}

int main (void) {
  int t = 3;
  int f = 1;
  swap(&t,&f);
  printf("t = %d\n",t);
  printf("f= %d",f);
}
```

&nbsp;

&nbsp;

### 구조체

구조체 선언은 struct를 사용할 수 있지만 추천하는 방법이 있다

``` c
#include <stdio.h>

typedef struct _구조체이름 {
  int a;
  int b;
} 구조체별칭; //구조체를 이용할려면 구조체 별칭을 이용한다

int main(void) {
  구조체별칭 p1;
  p1.a = 2;
  p1.b = 3;
}
```

_구조체 이름 부분은 생략 가능하고 생략한 구조체를 익명 구조체라고 한다
